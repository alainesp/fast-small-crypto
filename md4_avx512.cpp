//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// MD4 Message-Digest Algorithm
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Automatically generated code by SIMD-function library

#define SimdScalarType uint32_t
#include "simd.hpp"
using namespace simd;

//// <summary>
//// MD4 compress block
//// </summary>
//// <param name="state">The md4 state</param>
//// <param name="block">The message to compress</param>
extern "C" void md4_block_avx512_x4(simd::Vec512u32 state[16], const simd::Vec512u32 block[64]) noexcept
{
	simd::Vec512u32 a0, a1, a2, a3, b0, b1, b2, b3, c0, c1, c2, c3, d0, d1, d2, d3, t0, t1, t2, t3;

	// Load state
	a0 = load(state +  0);	a1 = load(state +  1);	a2 = load(state +  2);	a3 = load(state +  3);
	b0 = load(state +  4);	b1 = load(state +  5);	b2 = load(state +  6);	b3 = load(state +  7);
	c0 = load(state +  8);	c1 = load(state +  9);	c2 = load(state + 10);	c3 = load(state + 11);
	d0 = load(state + 12);	d1 = load(state + 13);	d2 = load(state + 14);	d3 = load(state + 15);

	// Round 1
	for (int i = 0; i < 4; i++) {
		a0 += load(block +  0);		a1 += load(block +  1);		a2 += load(block +  2);		a3 += load(block +  3);		t0 = ternary_logic<0xd8>(d0, c0, b0);		t1 = ternary_logic<0xd8>(d1, c1, b1);		t2 = ternary_logic<0xd8>(d2, c2, b2);		t3 = ternary_logic<0xd8>(d3, c3, b3);		a0 += t0;		a1 += t1;		a2 += t2;		a3 += t3;		a0 = rotl<uint32_t,  3>(a0,  3);		a1 = rotl<uint32_t,  3>(a1,  3);		a2 = rotl<uint32_t,  3>(a2,  3);		a3 = rotl<uint32_t,  3>(a3,  3);
		d0 += load(block +  4);		d1 += load(block +  5);		d2 += load(block +  6);		d3 += load(block +  7);		t0 = ternary_logic<0xd8>(c0, b0, a0);		t1 = ternary_logic<0xd8>(c1, b1, a1);		t2 = ternary_logic<0xd8>(c2, b2, a2);		t3 = ternary_logic<0xd8>(c3, b3, a3);		d0 += t0;		d1 += t1;		d2 += t2;		d3 += t3;		d0 = rotl<uint32_t,  7>(d0,  7);		d1 = rotl<uint32_t,  7>(d1,  7);		d2 = rotl<uint32_t,  7>(d2,  7);		d3 = rotl<uint32_t,  7>(d3,  7);
		c0 += load(block +  8);		c1 += load(block +  9);		c2 += load(block + 10);		c3 += load(block + 11);		t0 = ternary_logic<0xd8>(b0, a0, d0);		t1 = ternary_logic<0xd8>(b1, a1, d1);		t2 = ternary_logic<0xd8>(b2, a2, d2);		t3 = ternary_logic<0xd8>(b3, a3, d3);		c0 += t0;		c1 += t1;		c2 += t2;		c3 += t3;		c0 = rotl<uint32_t, 11>(c0, 11);		c1 = rotl<uint32_t, 11>(c1, 11);		c2 = rotl<uint32_t, 11>(c2, 11);		c3 = rotl<uint32_t, 11>(c3, 11);
		b0 += load(block + 12);		b1 += load(block + 13);		b2 += load(block + 14);		b3 += load(block + 15);		t0 = ternary_logic<0xd8>(a0, d0, c0);		t1 = ternary_logic<0xd8>(a1, d1, c1);		t2 = ternary_logic<0xd8>(a2, d2, c2);		t3 = ternary_logic<0xd8>(a3, d3, c3);		b0 += t0;		b1 += t1;		b2 += t2;		b3 += t3;		b0 = rotl<uint32_t, 19>(b0, 19);		b1 = rotl<uint32_t, 19>(b1, 19);		b2 = rotl<uint32_t, 19>(b2, 19);		b3 = rotl<uint32_t, 19>(b3, 19);
		block += 16;
	}
	block -= 64;

	// Round 2
	for (int i = 0; i < 4; i++) {
		a0 += load(block +  0);		a1 += load(block +  1);		a2 += load(block +  2);		a3 += load(block +  3);		t0 = ternary_logic<0xe8>(d0, c0, b0);		t1 = ternary_logic<0xe8>(d1, c1, b1);		t2 = ternary_logic<0xe8>(d2, c2, b2);		t3 = ternary_logic<0xe8>(d3, c3, b3);		a0 += UINT32_C(0x5a827999);		a1 += UINT32_C(0x5a827999);		a2 += UINT32_C(0x5a827999);		a3 += UINT32_C(0x5a827999);		a0 += t0;		a1 += t1;		a2 += t2;		a3 += t3;		a0 = rotl<uint32_t,  3>(a0,  3);		a1 = rotl<uint32_t,  3>(a1,  3);		a2 = rotl<uint32_t,  3>(a2,  3);		a3 = rotl<uint32_t,  3>(a3,  3);
		d0 += load(block + 16);		d1 += load(block + 17);		d2 += load(block + 18);		d3 += load(block + 19);		t0 = ternary_logic<0xe8>(c0, b0, a0);		t1 = ternary_logic<0xe8>(c1, b1, a1);		t2 = ternary_logic<0xe8>(c2, b2, a2);		t3 = ternary_logic<0xe8>(c3, b3, a3);		d0 += UINT32_C(0x5a827999);		d1 += UINT32_C(0x5a827999);		d2 += UINT32_C(0x5a827999);		d3 += UINT32_C(0x5a827999);		d0 += t0;		d1 += t1;		d2 += t2;		d3 += t3;		d0 = rotl<uint32_t,  5>(d0,  5);		d1 = rotl<uint32_t,  5>(d1,  5);		d2 = rotl<uint32_t,  5>(d2,  5);		d3 = rotl<uint32_t,  5>(d3,  5);
		c0 += load(block + 32);		c1 += load(block + 33);		c2 += load(block + 34);		c3 += load(block + 35);		t0 = ternary_logic<0xe8>(b0, a0, d0);		t1 = ternary_logic<0xe8>(b1, a1, d1);		t2 = ternary_logic<0xe8>(b2, a2, d2);		t3 = ternary_logic<0xe8>(b3, a3, d3);		c0 += UINT32_C(0x5a827999);		c1 += UINT32_C(0x5a827999);		c2 += UINT32_C(0x5a827999);		c3 += UINT32_C(0x5a827999);		c0 += t0;		c1 += t1;		c2 += t2;		c3 += t3;		c0 = rotl<uint32_t,  9>(c0,  9);		c1 = rotl<uint32_t,  9>(c1,  9);		c2 = rotl<uint32_t,  9>(c2,  9);		c3 = rotl<uint32_t,  9>(c3,  9);
		b0 += load(block + 48);		b1 += load(block + 49);		b2 += load(block + 50);		b3 += load(block + 51);		t0 = ternary_logic<0xe8>(a0, d0, c0);		t1 = ternary_logic<0xe8>(a1, d1, c1);		t2 = ternary_logic<0xe8>(a2, d2, c2);		t3 = ternary_logic<0xe8>(a3, d3, c3);		b0 += UINT32_C(0x5a827999);		b1 += UINT32_C(0x5a827999);		b2 += UINT32_C(0x5a827999);		b3 += UINT32_C(0x5a827999);		b0 += t0;		b1 += t1;		b2 += t2;		b3 += t3;		b0 = rotl<uint32_t, 13>(b0, 13);		b1 = rotl<uint32_t, 13>(b1, 13);		b2 = rotl<uint32_t, 13>(b2, 13);		b3 = rotl<uint32_t, 13>(b3, 13);
		block +=  4;
	}
	block -= 16;

	// Round 3
	a0 += load(block +  0);	a1 += load(block +  1);	a2 += load(block +  2);	a3 += load(block +  3);	t0 = ternary_logic<0x96>(d0, c0, b0);	t1 = ternary_logic<0x96>(d1, c1, b1);	t2 = ternary_logic<0x96>(d2, c2, b2);	t3 = ternary_logic<0x96>(d3, c3, b3);	a0 += UINT32_C(0x6ed9eba1);	a1 += UINT32_C(0x6ed9eba1);	a2 += UINT32_C(0x6ed9eba1);	a3 += UINT32_C(0x6ed9eba1);	a0 += t0;	a1 += t1;	a2 += t2;	a3 += t3;	a0 = rotl<uint32_t,  3>(a0,  3);	a1 = rotl<uint32_t,  3>(a1,  3);	a2 = rotl<uint32_t,  3>(a2,  3);	a3 = rotl<uint32_t,  3>(a3,  3);
	d0 += load(block + 32);	d1 += load(block + 33);	d2 += load(block + 34);	d3 += load(block + 35);	t0 = ternary_logic<0x96>(c0, b0, a0);	t1 = ternary_logic<0x96>(c1, b1, a1);	t2 = ternary_logic<0x96>(c2, b2, a2);	t3 = ternary_logic<0x96>(c3, b3, a3);	d0 += UINT32_C(0x6ed9eba1);	d1 += UINT32_C(0x6ed9eba1);	d2 += UINT32_C(0x6ed9eba1);	d3 += UINT32_C(0x6ed9eba1);	d0 += t0;	d1 += t1;	d2 += t2;	d3 += t3;	d0 = rotl<uint32_t,  9>(d0,  9);	d1 = rotl<uint32_t,  9>(d1,  9);	d2 = rotl<uint32_t,  9>(d2,  9);	d3 = rotl<uint32_t,  9>(d3,  9);
	c0 += load(block + 16);	c1 += load(block + 17);	c2 += load(block + 18);	c3 += load(block + 19);	t0 = ternary_logic<0x96>(b0, a0, d0);	t1 = ternary_logic<0x96>(b1, a1, d1);	t2 = ternary_logic<0x96>(b2, a2, d2);	t3 = ternary_logic<0x96>(b3, a3, d3);	c0 += UINT32_C(0x6ed9eba1);	c1 += UINT32_C(0x6ed9eba1);	c2 += UINT32_C(0x6ed9eba1);	c3 += UINT32_C(0x6ed9eba1);	c0 += t0;	c1 += t1;	c2 += t2;	c3 += t3;	c0 = rotl<uint32_t, 11>(c0, 11);	c1 = rotl<uint32_t, 11>(c1, 11);	c2 = rotl<uint32_t, 11>(c2, 11);	c3 = rotl<uint32_t, 11>(c3, 11);
	b0 += load(block + 48);	b1 += load(block + 49);	b2 += load(block + 50);	b3 += load(block + 51);	t0 = ternary_logic<0x96>(a0, d0, c0);	t1 = ternary_logic<0x96>(a1, d1, c1);	t2 = ternary_logic<0x96>(a2, d2, c2);	t3 = ternary_logic<0x96>(a3, d3, c3);	b0 += UINT32_C(0x6ed9eba1);	b1 += UINT32_C(0x6ed9eba1);	b2 += UINT32_C(0x6ed9eba1);	b3 += UINT32_C(0x6ed9eba1);	b0 += t0;	b1 += t1;	b2 += t2;	b3 += t3;	b0 = rotl<uint32_t, 15>(b0, 15);	b1 = rotl<uint32_t, 15>(b1, 15);	b2 = rotl<uint32_t, 15>(b2, 15);	b3 = rotl<uint32_t, 15>(b3, 15);
	a0 += load(block +  8);	a1 += load(block +  9);	a2 += load(block + 10);	a3 += load(block + 11);	t0 = ternary_logic<0x96>(d0, c0, b0);	t1 = ternary_logic<0x96>(d1, c1, b1);	t2 = ternary_logic<0x96>(d2, c2, b2);	t3 = ternary_logic<0x96>(d3, c3, b3);	a0 += UINT32_C(0x6ed9eba1);	a1 += UINT32_C(0x6ed9eba1);	a2 += UINT32_C(0x6ed9eba1);	a3 += UINT32_C(0x6ed9eba1);	a0 += t0;	a1 += t1;	a2 += t2;	a3 += t3;	a0 = rotl<uint32_t,  3>(a0,  3);	a1 = rotl<uint32_t,  3>(a1,  3);	a2 = rotl<uint32_t,  3>(a2,  3);	a3 = rotl<uint32_t,  3>(a3,  3);
	d0 += load(block + 40);	d1 += load(block + 41);	d2 += load(block + 42);	d3 += load(block + 43);	t0 = ternary_logic<0x96>(c0, b0, a0);	t1 = ternary_logic<0x96>(c1, b1, a1);	t2 = ternary_logic<0x96>(c2, b2, a2);	t3 = ternary_logic<0x96>(c3, b3, a3);	d0 += UINT32_C(0x6ed9eba1);	d1 += UINT32_C(0x6ed9eba1);	d2 += UINT32_C(0x6ed9eba1);	d3 += UINT32_C(0x6ed9eba1);	d0 += t0;	d1 += t1;	d2 += t2;	d3 += t3;	d0 = rotl<uint32_t,  9>(d0,  9);	d1 = rotl<uint32_t,  9>(d1,  9);	d2 = rotl<uint32_t,  9>(d2,  9);	d3 = rotl<uint32_t,  9>(d3,  9);
	c0 += load(block + 24);	c1 += load(block + 25);	c2 += load(block + 26);	c3 += load(block + 27);	t0 = ternary_logic<0x96>(b0, a0, d0);	t1 = ternary_logic<0x96>(b1, a1, d1);	t2 = ternary_logic<0x96>(b2, a2, d2);	t3 = ternary_logic<0x96>(b3, a3, d3);	c0 += UINT32_C(0x6ed9eba1);	c1 += UINT32_C(0x6ed9eba1);	c2 += UINT32_C(0x6ed9eba1);	c3 += UINT32_C(0x6ed9eba1);	c0 += t0;	c1 += t1;	c2 += t2;	c3 += t3;	c0 = rotl<uint32_t, 11>(c0, 11);	c1 = rotl<uint32_t, 11>(c1, 11);	c2 = rotl<uint32_t, 11>(c2, 11);	c3 = rotl<uint32_t, 11>(c3, 11);
	b0 += load(block + 56);	b1 += load(block + 57);	b2 += load(block + 58);	b3 += load(block + 59);	t0 = ternary_logic<0x96>(a0, d0, c0);	t1 = ternary_logic<0x96>(a1, d1, c1);	t2 = ternary_logic<0x96>(a2, d2, c2);	t3 = ternary_logic<0x96>(a3, d3, c3);	b0 += UINT32_C(0x6ed9eba1);	b1 += UINT32_C(0x6ed9eba1);	b2 += UINT32_C(0x6ed9eba1);	b3 += UINT32_C(0x6ed9eba1);	b0 += t0;	b1 += t1;	b2 += t2;	b3 += t3;	b0 = rotl<uint32_t, 15>(b0, 15);	b1 = rotl<uint32_t, 15>(b1, 15);	b2 = rotl<uint32_t, 15>(b2, 15);	b3 = rotl<uint32_t, 15>(b3, 15);
	a0 += load(block +  4);	a1 += load(block +  5);	a2 += load(block +  6);	a3 += load(block +  7);	t0 = ternary_logic<0x96>(d0, c0, b0);	t1 = ternary_logic<0x96>(d1, c1, b1);	t2 = ternary_logic<0x96>(d2, c2, b2);	t3 = ternary_logic<0x96>(d3, c3, b3);	a0 += UINT32_C(0x6ed9eba1);	a1 += UINT32_C(0x6ed9eba1);	a2 += UINT32_C(0x6ed9eba1);	a3 += UINT32_C(0x6ed9eba1);	a0 += t0;	a1 += t1;	a2 += t2;	a3 += t3;	a0 = rotl<uint32_t,  3>(a0,  3);	a1 = rotl<uint32_t,  3>(a1,  3);	a2 = rotl<uint32_t,  3>(a2,  3);	a3 = rotl<uint32_t,  3>(a3,  3);
	d0 += load(block + 36);	d1 += load(block + 37);	d2 += load(block + 38);	d3 += load(block + 39);	t0 = ternary_logic<0x96>(c0, b0, a0);	t1 = ternary_logic<0x96>(c1, b1, a1);	t2 = ternary_logic<0x96>(c2, b2, a2);	t3 = ternary_logic<0x96>(c3, b3, a3);	d0 += UINT32_C(0x6ed9eba1);	d1 += UINT32_C(0x6ed9eba1);	d2 += UINT32_C(0x6ed9eba1);	d3 += UINT32_C(0x6ed9eba1);	d0 += t0;	d1 += t1;	d2 += t2;	d3 += t3;	d0 = rotl<uint32_t,  9>(d0,  9);	d1 = rotl<uint32_t,  9>(d1,  9);	d2 = rotl<uint32_t,  9>(d2,  9);	d3 = rotl<uint32_t,  9>(d3,  9);
	c0 += load(block + 20);	c1 += load(block + 21);	c2 += load(block + 22);	c3 += load(block + 23);	t0 = ternary_logic<0x96>(b0, a0, d0);	t1 = ternary_logic<0x96>(b1, a1, d1);	t2 = ternary_logic<0x96>(b2, a2, d2);	t3 = ternary_logic<0x96>(b3, a3, d3);	c0 += UINT32_C(0x6ed9eba1);	c1 += UINT32_C(0x6ed9eba1);	c2 += UINT32_C(0x6ed9eba1);	c3 += UINT32_C(0x6ed9eba1);	c0 += t0;	c1 += t1;	c2 += t2;	c3 += t3;	c0 = rotl<uint32_t, 11>(c0, 11);	c1 = rotl<uint32_t, 11>(c1, 11);	c2 = rotl<uint32_t, 11>(c2, 11);	c3 = rotl<uint32_t, 11>(c3, 11);
	b0 += load(block + 52);	b1 += load(block + 53);	b2 += load(block + 54);	b3 += load(block + 55);	t0 = ternary_logic<0x96>(a0, d0, c0);	t1 = ternary_logic<0x96>(a1, d1, c1);	t2 = ternary_logic<0x96>(a2, d2, c2);	t3 = ternary_logic<0x96>(a3, d3, c3);	b0 += UINT32_C(0x6ed9eba1);	b1 += UINT32_C(0x6ed9eba1);	b2 += UINT32_C(0x6ed9eba1);	b3 += UINT32_C(0x6ed9eba1);	b0 += t0;	b1 += t1;	b2 += t2;	b3 += t3;	b0 = rotl<uint32_t, 15>(b0, 15);	b1 = rotl<uint32_t, 15>(b1, 15);	b2 = rotl<uint32_t, 15>(b2, 15);	b3 = rotl<uint32_t, 15>(b3, 15);
	a0 += load(block + 12);	a1 += load(block + 13);	a2 += load(block + 14);	a3 += load(block + 15);	t0 = ternary_logic<0x96>(d0, c0, b0);	t1 = ternary_logic<0x96>(d1, c1, b1);	t2 = ternary_logic<0x96>(d2, c2, b2);	t3 = ternary_logic<0x96>(d3, c3, b3);	a0 += UINT32_C(0x6ed9eba1);	a1 += UINT32_C(0x6ed9eba1);	a2 += UINT32_C(0x6ed9eba1);	a3 += UINT32_C(0x6ed9eba1);	a0 += t0;	a1 += t1;	a2 += t2;	a3 += t3;	a0 = rotl<uint32_t,  3>(a0,  3);	a1 = rotl<uint32_t,  3>(a1,  3);	a2 = rotl<uint32_t,  3>(a2,  3);	a3 = rotl<uint32_t,  3>(a3,  3);
	d0 += load(block + 44);	d1 += load(block + 45);	d2 += load(block + 46);	d3 += load(block + 47);	t0 = ternary_logic<0x96>(c0, b0, a0);	t1 = ternary_logic<0x96>(c1, b1, a1);	t2 = ternary_logic<0x96>(c2, b2, a2);	t3 = ternary_logic<0x96>(c3, b3, a3);	d0 += UINT32_C(0x6ed9eba1);	d1 += UINT32_C(0x6ed9eba1);	d2 += UINT32_C(0x6ed9eba1);	d3 += UINT32_C(0x6ed9eba1);	d0 += t0;	d1 += t1;	d2 += t2;	d3 += t3;	d0 = rotl<uint32_t,  9>(d0,  9);	d1 = rotl<uint32_t,  9>(d1,  9);	d2 = rotl<uint32_t,  9>(d2,  9);	d3 = rotl<uint32_t,  9>(d3,  9);
	c0 += load(block + 28);	c1 += load(block + 29);	c2 += load(block + 30);	c3 += load(block + 31);	t0 = ternary_logic<0x96>(b0, a0, d0);	t1 = ternary_logic<0x96>(b1, a1, d1);	t2 = ternary_logic<0x96>(b2, a2, d2);	t3 = ternary_logic<0x96>(b3, a3, d3);	c0 += UINT32_C(0x6ed9eba1);	c1 += UINT32_C(0x6ed9eba1);	c2 += UINT32_C(0x6ed9eba1);	c3 += UINT32_C(0x6ed9eba1);	c0 += t0;	c1 += t1;	c2 += t2;	c3 += t3;	c0 = rotl<uint32_t, 11>(c0, 11);	c1 = rotl<uint32_t, 11>(c1, 11);	c2 = rotl<uint32_t, 11>(c2, 11);	c3 = rotl<uint32_t, 11>(c3, 11);
	b0 += load(block + 60);	b1 += load(block + 61);	b2 += load(block + 62);	b3 += load(block + 63);	t0 = ternary_logic<0x96>(a0, d0, c0);	t1 = ternary_logic<0x96>(a1, d1, c1);	t2 = ternary_logic<0x96>(a2, d2, c2);	t3 = ternary_logic<0x96>(a3, d3, c3);	b0 += UINT32_C(0x6ed9eba1);	b1 += UINT32_C(0x6ed9eba1);	b2 += UINT32_C(0x6ed9eba1);	b3 += UINT32_C(0x6ed9eba1);	b0 += t0;	b1 += t1;	b2 += t2;	b3 += t3;	b0 = rotl<uint32_t, 15>(b0, 15);	b1 = rotl<uint32_t, 15>(b1, 15);	b2 = rotl<uint32_t, 15>(b2, 15);	b3 = rotl<uint32_t, 15>(b3, 15);

	// Save state
	store(state +  0, load(state +  0) + a0);	store(state +  1, load(state +  1) + a1);	store(state +  2, load(state +  2) + a2);	store(state +  3, load(state +  3) + a3);
	store(state + 12, load(state + 12) + d0);	store(state + 13, load(state + 13) + d1);	store(state + 14, load(state + 14) + d2);	store(state + 15, load(state + 15) + d3);
	store(state +  8, load(state +  8) + c0);	store(state +  9, load(state +  9) + c1);	store(state + 10, load(state + 10) + c2);	store(state + 11, load(state + 11) + c3);
	store(state +  4, load(state +  4) + b0);	store(state +  5, load(state +  5) + b1);	store(state +  6, load(state +  6) + b2);	store(state +  7, load(state +  7) + b3);
}

